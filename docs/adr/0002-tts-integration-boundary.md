# ADR 0002：TTS 接入边界与供应商解耦

## 状态

Accepted

## 背景

本项目提供 read-aloud 相关的“可组合积木”（分段、定位、高亮、播放状态机），但在语音合成（TTS）与音频播放链路上，不同产品/业务的差异远大于共性：

- 供应商差异：模型、音色、格式、限流/配额、计费粒度、延迟与稳定性均不同。
- 体验策略差异：缓存/预取、失败重试、降级策略（跳过/改读/提示）、并发控制等很难在库内做出通用且正确的默认值。
- 运行环境差异：浏览器端（HTMLAudio/WebAudio）、原生桥（iOS/Android）、桌面端等播放能力与约束不同。
- 安全边界：任何供应商的 API Key 都不应暴露在浏览器端；浏览器直连会带来密钥泄露与滥用风险。

因此，“在核心库中内置某个供应商的直连 TTS 适配器/播放实现”既带来长期维护成本，也会把安全与产品策略的责任错误地推给基础库。

## 决策

### 1) 核心库不内置任何 TTS 供应商实现

- 核心库不提供直连 OpenAI 或其他供应商的 TTS 实现，不处理 API Key，不内置请求与鉴权逻辑。
- 核心库不承诺某种音频播放实现（例如 HTMLAudio/WebAudio/Native bridge），只定义播放驱动接口。

### 2) 通过 `PlaybackControllerDriver` 把 TTS/播放职责下沉到应用层

核心库只提供：

- `PlaybackController`：播放状态机与事件回调。
- `PlaybackControllerDriver`：播放驱动接口，由应用层实现（可对接 TTS 服务、缓存、预取与播放设备）。
- `SpeechSegment` / `speechSegmentsFromDocument()`：分段与定位数据结构与工具。
- `SpeechHighlighter`：与 `SpeechSegment.anchor` 对齐的高亮同步能力。

应用层的推荐接入方式：

- 由应用层提供同源服务端代理（例如 `/api/tts`），由服务端持有供应商密钥并返回音频数据。
- 由应用层实现缓存与预取策略（例如提前合成后续 1–2 个 segment，或 IndexedDB 缓存）。

## 备选方案

### A) 在核心库内置单一供应商适配器（例如 OpenAI）

优点：

- 用户上手成本更低，demo 更“开箱即用”。

缺点：

- 把密钥管理与计费风险引入客户端；难以给出安全默认值。
- 供应商变更与策略变更会频繁引入破坏性改动与维护负担。
- 难以兼容多运行时的播放链路，增加核心库体积与耦合。

### B) 以可选插件包形式提供供应商适配器

优点：

- 核心库保持轻量，适配器可独立迭代。

缺点：

- 仍需解决“密钥不下发到客户端”的边界问题；插件仍然需要依赖服务端代理或只提供协议/示例。
- 生态与版本兼容成本上升（核心库与插件的版本矩阵）。

## 影响与后果

收益：

- 明确安全边界：核心库不触达任何密钥与鉴权逻辑。
- 降低耦合与维护成本：核心库聚焦通用的分段/定位/高亮/播放状态机能力。
- 提升可移植性：应用层可按运行时选择合适的播放实现与策略。

代价：

- 应用层需要自行实现 `PlaybackControllerDriver` 与服务端代理，并对接缓存/预取/错误策略。
- 官方示例只能提供 API 形状与接入建议，无法覆盖所有产品策略。

## 相关文档

- `docs/read-aloud.md`：包含最小串联示例（`PlaybackControllerDriver` + `/api/tts`）。
- `docs/tts-review.md`：包含对 read-aloud 相关实现与历史 TTS 直连风险的审查结论。

